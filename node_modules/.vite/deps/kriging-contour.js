import "./chunk-QDSQJ443.js";

// node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(compare) {
  if (compare.length === 1)
    compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x) {
    return ascending_default(f(d), x);
  };
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

// node_modules/d3-array/src/extent.js
function extent_default(values, valueof) {
  var n = values.length, i = -1, value, min, max;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          if ((value = values[i]) != null) {
            if (min > value)
              min = value;
            if (max < value)
              max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value)
              min = value;
            if (max < value)
              max = value;
          }
        }
      }
    }
  }
  return [min, max];
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/range.js
function range_default(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
  while (++i < n) {
    range[i] = start + i * step;
  }
  return range;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/d3-array/src/threshold/sturges.js
function sturges_default(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

// node_modules/kriging-contour/node_modules/d3-contour/src/array.js
var array2 = Array.prototype;
var slice2 = array2.slice;

// node_modules/kriging-contour/node_modules/d3-contour/src/ascending.js
function ascending_default2(a, b) {
  return a - b;
}

// node_modules/kriging-contour/node_modules/d3-contour/src/area.js
function area_default(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

// node_modules/kriging-contour/node_modules/d3-contour/src/constant.js
function constant_default2(x) {
  return function() {
    return x;
  };
}

// node_modules/kriging-contour/node_modules/d3-contour/src/contains.js
function contains_default(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n)
    if (c = ringContains(ring, hole[i]))
      return c;
  return 0;
}
function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point))
      return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi)
      contains = -contains;
  }
  return contains;
}
function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}
function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

// node_modules/kriging-contour/node_modules/d3-contour/src/noop.js
function noop_default() {
}

// node_modules/kriging-contour/node_modules/d3-contour/src/contours.js
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours_default() {
  var dx = 1, dy = 1, threshold = sturges_default, smooth = smoothLinear;
  function contours(values) {
    var tz = threshold(values);
    if (!Array.isArray(tz)) {
      var domain = extent_default(values), start = domain[0], stop = domain[1];
      tz = tickStep(start, stop, tz);
      tz = range_default(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending_default2);
    }
    return tz.map(function(value) {
      return contour(values, value);
    });
  }
  function contour(values, value) {
    var polygons = [], holes = [];
    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area_default(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x, y, t0, t1, t2, t3;
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);
    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y], end = [line[1][0] + x, line[1][1] + y], startIndex = index(start), endIndex = index(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start, end] };
      }
    }
  }
  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0], y = point[1], xt = x | 0, yt = y | 0, v0, v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours.contour = contour;
  contours.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };
  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant_default2(slice2.call(_)) : constant_default2(_), contours) : threshold;
  };
  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
  };
  return contours;
}

// node_modules/kriging-contour/src/kriging.js
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};
Array.prototype.min = function() {
  return Math.min.apply(null, this);
};
Array.prototype.mean = function() {
  var i, sum;
  for (i = 0, sum = 0; i < this.length; i++)
    sum += this[i];
  return sum / this.length;
};
Array.prototype.rep = function(n) {
  var arrayn = new Array(n);
  var v = this[0];
  for (var i = 0; i < n; i++) {
    arrayn[i] = v;
  }
  return arrayn;
};
Array.prototype.pip = function(x, y) {
  var i, j, c = false;
  for (i = 0, j = this.length - 1; i < this.length; j = i++) {
    if (this[i][1] > y != this[j][1] > y && x < (this[j][0] - this[i][0]) * (y - this[i][1]) / (this[j][1] - this[i][1]) + this[i][0]) {
      c = !c;
    }
  }
  return c;
};
function kriging_matrix_diag(c, n) {
  var i, Z = [0].rep(n * n);
  for (i = 0; i < n; i++)
    Z[i * n + i] = c;
  return Z;
}
function kriging_matrix_transpose(X, n, m) {
  var i, j, Z = Array(m * n);
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      Z[j * n + i] = X[i * m + j];
  return Z;
}
function kriging_matrix_add(X, Y, n, m) {
  var i, j, Z = Array(n * m);
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      Z[i * m + j] = X[i * m + j] + Y[i * m + j];
  return Z;
}
function kriging_matrix_multiply(X, Y, n, m, p) {
  var i, j, k, Z = Array(n * p);
  for (i = 0; i < n; i++) {
    for (j = 0; j < p; j++) {
      Z[i * p + j] = 0;
      for (k = 0; k < m; k++)
        Z[i * p + j] += X[i * m + k] * Y[k * p + j];
    }
  }
  return Z;
}
function kriging_matrix_chol(X, n) {
  var i, j, k, sum, p = Array(n);
  for (i = 0; i < n; i++)
    p[i] = X[i * n + i];
  for (i = 0; i < n; i++) {
    for (j = 0; j < i; j++)
      p[i] -= X[i * n + j] * X[i * n + j];
    if (p[i] <= 0)
      return false;
    p[i] = Math.sqrt(p[i]);
    for (j = i + 1; j < n; j++) {
      for (k = 0; k < i; k++)
        X[j * n + i] -= X[j * n + k] * X[i * n + k];
      X[j * n + i] /= p[i];
    }
  }
  for (i = 0; i < n; i++)
    X[i * n + i] = p[i];
  return true;
}
function kriging_matrix_chol2inv(X, n) {
  var i, j, k, sum;
  for (i = 0; i < n; i++) {
    X[i * n + i] = 1 / X[i * n + i];
    for (j = i + 1; j < n; j++) {
      sum = 0;
      for (k = i; k < j; k++)
        sum -= X[j * n + k] * X[k * n + i];
      X[j * n + i] = sum / X[j * n + j];
    }
  }
  for (i = 0; i < n; i++)
    for (j = i + 1; j < n; j++)
      X[i * n + j] = 0;
  for (i = 0; i < n; i++) {
    X[i * n + i] *= X[i * n + i];
    for (k = i + 1; k < n; k++)
      X[i * n + i] += X[k * n + i] * X[k * n + i];
    for (j = i + 1; j < n; j++)
      for (k = j; k < n; k++)
        X[i * n + j] += X[k * n + i] * X[k * n + j];
  }
  for (i = 0; i < n; i++)
    for (j = 0; j < i; j++)
      X[i * n + j] = X[j * n + i];
}
function kriging_matrix_solve(X, n) {
  var m = n;
  var b = Array(n * n);
  var indxc = Array(n);
  var indxr = Array(n);
  var ipiv = Array(n);
  var i, icol, irow, j, k, l, ll;
  var big, dum, pivinv, temp;
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      if (i == j)
        b[i * n + j] = 1;
      else
        b[i * n + j] = 0;
    }
  for (j = 0; j < n; j++)
    ipiv[j] = 0;
  for (i = 0; i < n; i++) {
    big = 0;
    for (j = 0; j < n; j++) {
      if (ipiv[j] != 1) {
        for (k = 0; k < n; k++) {
          if (ipiv[k] == 0) {
            if (Math.abs(X[j * n + k]) >= big) {
              big = Math.abs(X[j * n + k]);
              irow = j;
              icol = k;
            }
          }
        }
      }
    }
    ++ipiv[icol];
    if (irow != icol) {
      for (l = 0; l < n; l++) {
        temp = X[irow * n + l];
        X[irow * n + l] = X[icol * n + l];
        X[icol * n + l] = temp;
      }
      for (l = 0; l < m; l++) {
        temp = b[irow * n + l];
        b[irow * n + l] = b[icol * n + l];
        b[icol * n + l] = temp;
      }
    }
    indxr[i] = irow;
    indxc[i] = icol;
    if (X[icol * n + icol] == 0)
      return false;
    pivinv = 1 / X[icol * n + icol];
    X[icol * n + icol] = 1;
    for (l = 0; l < n; l++)
      X[icol * n + l] *= pivinv;
    for (l = 0; l < m; l++)
      b[icol * n + l] *= pivinv;
    for (ll = 0; ll < n; ll++) {
      if (ll != icol) {
        dum = X[ll * n + icol];
        X[ll * n + icol] = 0;
        for (l = 0; l < n; l++)
          X[ll * n + l] -= X[icol * n + l] * dum;
        for (l = 0; l < m; l++)
          b[ll * n + l] -= b[icol * n + l] * dum;
      }
    }
  }
  for (l = n - 1; l >= 0; l--)
    if (indxr[l] != indxc[l]) {
      for (k = 0; k < n; k++) {
        temp = X[k * n + indxr[l]];
        X[k * n + indxr[l]] = X[k * n + indxc[l]];
        X[k * n + indxc[l]] = temp;
      }
    }
  return true;
}
function kriging_variogram_gaussian(h, nugget, range, sill, A) {
  return nugget + (sill - nugget) / range * (1 - Math.exp(-(1 / A) * Math.pow(h / range, 2)));
}
function kriging_variogram_exponential(h, nugget, range, sill, A) {
  return nugget + (sill - nugget) / range * (1 - Math.exp(-(1 / A) * (h / range)));
}
function kriging_variogram_spherical(h, nugget, range, sill, A) {
  if (h > range)
    return nugget + (sill - nugget) / range;
  return nugget + (sill - nugget) / range * (1.5 * (h / range) - 0.5 * Math.pow(h / range, 3));
}
var kriging = {};
kriging.train = function(t, x, y, model, sigma2, alpha) {
  var variogram = {
    t,
    x,
    y,
    nugget: 0,
    range: 0,
    sill: 0,
    A: 1 / 3,
    n: 0
  };
  switch (model) {
    case "gaussian":
      variogram.model = kriging_variogram_gaussian;
      break;
    case "exponential":
      variogram.model = kriging_variogram_exponential;
      break;
    case "spherical":
      variogram.model = kriging_variogram_spherical;
      break;
  }
  ;
  var i, j, k, l, n = t.length;
  var distance = Array((n * n - n) / 2);
  for (i = 0, k = 0; i < n; i++)
    for (j = 0; j < i; j++, k++) {
      distance[k] = Array(2);
      distance[k][0] = Math.pow(
        Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2),
        0.5
      );
      distance[k][1] = Math.abs(t[i] - t[j]);
    }
  distance.sort(function(a, b) {
    return a[0] - b[0];
  });
  variogram.range = distance[(n * n - n) / 2 - 1][0];
  var lags = (n * n - n) / 2 > 30 ? 30 : (n * n - n) / 2;
  var tolerance = variogram.range / lags;
  var lag = [0].rep(lags);
  var semi = [0].rep(lags);
  if (lags < 30) {
    for (l = 0; l < lags; l++) {
      lag[l] = distance[l][0];
      semi[l] = distance[l][1];
    }
  } else {
    for (i = 0, j = 0, k = 0, l = 0; i < lags && j < (n * n - n) / 2; i++, k = 0) {
      while (distance[j][0] <= (i + 1) * tolerance) {
        lag[l] += distance[j][0];
        semi[l] += distance[j][1];
        j++;
        k++;
        if (j >= (n * n - n) / 2)
          break;
      }
      if (k > 0) {
        lag[l] /= k;
        semi[l] /= k;
        l++;
      }
    }
    if (l < 2)
      return variogram;
  }
  n = l;
  variogram.range = lag[n - 1] - lag[0];
  var X = [1].rep(2 * n);
  var Y = Array(n);
  var A = variogram.A;
  for (i = 0; i < n; i++) {
    switch (model) {
      case "gaussian":
        X[i * 2 + 1] = 1 - Math.exp(-(1 / A) * Math.pow(lag[i] / variogram.range, 2));
        break;
      case "exponential":
        X[i * 2 + 1] = 1 - Math.exp(-(1 / A) * lag[i] / variogram.range);
        break;
      case "spherical":
        X[i * 2 + 1] = 1.5 * (lag[i] / variogram.range) - 0.5 * Math.pow(lag[i] / variogram.range, 3);
        break;
    }
    ;
    Y[i] = semi[i];
  }
  var Xt = kriging_matrix_transpose(X, n, 2);
  var Z = kriging_matrix_multiply(Xt, X, 2, n, 2);
  Z = kriging_matrix_add(Z, kriging_matrix_diag(1 / alpha, 2), 2, 2);
  var cloneZ = Z.slice(0);
  if (kriging_matrix_chol(Z, 2))
    kriging_matrix_chol2inv(Z, 2);
  else {
    kriging_matrix_solve(cloneZ, 2);
    Z = cloneZ;
  }
  var W = kriging_matrix_multiply(kriging_matrix_multiply(Z, Xt, 2, 2, n), Y, 2, n, 1);
  variogram.nugget = W[0];
  variogram.sill = W[1] * variogram.range + variogram.nugget;
  variogram.n = x.length;
  n = x.length;
  var K = Array(n * n);
  for (i = 0; i < n; i++) {
    for (j = 0; j < i; j++) {
      K[i * n + j] = variogram.model(
        Math.pow(Math.pow(x[i] - x[j], 2) + Math.pow(y[i] - y[j], 2), 0.5),
        variogram.nugget,
        variogram.range,
        variogram.sill,
        variogram.A
      );
      K[j * n + i] = K[i * n + j];
    }
    K[i * n + i] = variogram.model(
      0,
      variogram.nugget,
      variogram.range,
      variogram.sill,
      variogram.A
    );
  }
  var C = kriging_matrix_add(K, kriging_matrix_diag(sigma2, n), n, n);
  var cloneC = C.slice(0);
  if (kriging_matrix_chol(C, n))
    kriging_matrix_chol2inv(C, n);
  else {
    kriging_matrix_solve(cloneC, n);
    C = cloneC;
  }
  var K = C.slice(0);
  var M = kriging_matrix_multiply(C, t, n, n, 1);
  variogram.K = K;
  variogram.M = M;
  return variogram;
};
kriging.predict = function(x, y, variogram) {
  var i, k = Array(variogram.n);
  for (i = 0; i < variogram.n; i++)
    k[i] = variogram.model(
      Math.pow(Math.pow(x - variogram.x[i], 2) + Math.pow(y - variogram.y[i], 2), 0.5),
      variogram.nugget,
      variogram.range,
      variogram.sill,
      variogram.A
    );
  return kriging_matrix_multiply(k, variogram.M, 1, variogram.n, 1)[0];
};
kriging.variance = function(x, y, variogram) {
  var i, k = Array(variogram.n);
  for (i = 0; i < variogram.n; i++)
    k[i] = variogram.model(
      Math.pow(Math.pow(x - variogram.x[i], 2) + Math.pow(y - variogram.y[i], 2), 0.5),
      variogram.nugget,
      variogram.range,
      variogram.sill,
      variogram.A
    );
  return variogram.model(
    0,
    variogram.nugget,
    variogram.range,
    variogram.sill,
    variogram.A
  ) + kriging_matrix_multiply(
    kriging_matrix_multiply(
      k,
      variogram.K,
      1,
      variogram.n,
      variogram.n
    ),
    k,
    1,
    variogram.n,
    1
  )[0];
};
kriging.getGridInfo = function(bbox, variogram, width) {
  var grid = [];
  var xlim = [bbox[0], bbox[2]];
  var ylim = [bbox[1], bbox[3]];
  var zlim = [variogram.t.min(), variogram.t.max()];
  var geoX_width = xlim[1] - xlim[0];
  var geoY_width = ylim[1] - ylim[0];
  let x_width, y_width;
  if (!width)
    x_width = 200;
  else
    x_width = Math.ceil(width);
  y_width = Math.ceil(x_width / (geoX_width / geoY_width));
  var x_resolution = geoX_width * 1 / x_width;
  var y_resolution = geoY_width * 1 / y_width;
  var xtarget, ytarget;
  for (let j = 0; j < y_width; j++) {
    for (let k = 0; k < x_width; k++) {
      xtarget = bbox[0] + k * x_resolution;
      ytarget = bbox[1] + j * y_resolution;
      grid.push(kriging.predict(xtarget, ytarget, variogram));
    }
  }
  return {
    grid,
    n: x_width,
    m: y_width,
    xlim,
    ylim,
    zlim,
    x_resolution,
    y_resolution
  };
};
kriging.getVectorContour = function(gridInfo, breaks) {
  var _contours = contours_default().size([gridInfo.n, gridInfo.m]).thresholds(breaks)(gridInfo.grid);
  let dataset = {
    "type": "FeatureCollection",
    "features": []
  };
  var geoX_width = gridInfo.xlim[1] - gridInfo.xlim[0];
  var geoY_width = gridInfo.ylim[1] - gridInfo.ylim[0];
  _contours.forEach((contour) => {
    contour.coordinates.forEach((polygon) => {
      let _polygon = polygon.map((ring) => {
        let _ring = ring.map(function(coor) {
          let lon = gridInfo.xlim[0] + geoX_width * (coor[0] * 1 / gridInfo.n);
          let lat = gridInfo.ylim[0] + geoY_width * (coor[1] * 1 / gridInfo.m);
          return [lon, lat];
        });
        return _ring;
      });
      dataset.features.push({
        "type": "Feature",
        "properties": {
          "contour_value": contour.value
        },
        "geometry": {
          "type": "Polygon",
          "coordinates": _polygon
        }
      });
    });
  });
  return dataset;
};
kriging.drawCanvasContour = function(gridInfo, canvas, xlim, ylim, colors) {
  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  var range = [xlim[1] - xlim[0], ylim[1] - ylim[0], gridInfo.zlim[1] - gridInfo.zlim[0]];
  var n = gridInfo.n;
  var m = gridInfo.m;
  var wx = Math.ceil(gridInfo.x_resolution * canvas.width / (xlim[1] - xlim[0]));
  var wy = Math.ceil(gridInfo.y_resolution * canvas.height / (ylim[1] - ylim[0]));
  for (let i = 0; i < m; i++)
    for (let j = 0; j < n; j++) {
      let _index = i * n + j;
      if (gridInfo.grid[_index] == void 0)
        continue;
      let x = canvas.width * (j * gridInfo.x_resolution + gridInfo.xlim[0] - xlim[0]) / range[0];
      let y = canvas.height * (1 - (i * gridInfo.y_resolution + gridInfo.ylim[0] - ylim[0]) / range[1]);
      let z = (gridInfo.grid[_index] - gridInfo.zlim[0]) / range[2];
      if (z < 0)
        z = 0;
      else if (z > 1)
        z = 1;
      ctx.fillStyle = colors[Math.floor((colors.length - 1) * z)];
      ctx.fillRect(Math.round(x - wx / 2), Math.round(y - wy / 2), wx, wy);
    }
};

// node_modules/kriging-contour/src/index.js
function _getKrigingGridInfo(featureCollection, weight, krigingParams) {
  let values = [], lons = [], lats = [];
  let extent = [1e8, 1e8, -1e8, -1e8];
  featureCollection.features.forEach((feature) => {
    values.push(feature.properties[weight]);
    lons.push(feature.geometry.coordinates[0]);
    lats.push(feature.geometry.coordinates[1]);
    if (extent[0] > feature.geometry.coordinates[0])
      extent[0] = feature.geometry.coordinates[0];
    if (extent[1] > feature.geometry.coordinates[1])
      extent[1] = feature.geometry.coordinates[1];
    if (extent[2] < feature.geometry.coordinates[0])
      extent[2] = feature.geometry.coordinates[0];
    if (extent[3] < feature.geometry.coordinates[1])
      extent[3] = feature.geometry.coordinates[1];
  });
  let variogram = kriging.train(values, lons, lats, krigingParams.model, krigingParams.sigma2, krigingParams.alpha);
  let gridinfo = kriging.getGridInfo(extent, variogram, 200);
  return gridinfo;
}
function getVectorContour(featureCollection, weight, krigingParams, breaks) {
  let gridinfo = _getKrigingGridInfo(featureCollection, weight, krigingParams);
  let vectorContour = kriging.getVectorContour(gridinfo, breaks);
  return vectorContour;
}
function drawCanvasContour(featureCollection, weight, krigingParams, canvas, xlim, ylim, colors) {
  let gridinfo = _getKrigingGridInfo(featureCollection, weight, krigingParams);
  kriging.drawCanvasContour(gridinfo, canvas, xlim, ylim, colors);
}
export {
  drawCanvasContour,
  getVectorContour
};
//# sourceMappingURL=kriging-contour.js.map
